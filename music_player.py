import tkinter as tk  # The library for building the GUI.
from tkinter import ttk  # Extension for advanced widgets in tkinter.
import pygame  # Library for playing sounds and music.
import os  # Library for interacting with the file system.
from mutagen.mp3 import MP3  # Library for manipulating MP3 files and getting information about them.
import time  # Time management library.
import cv2  # Library for capturing and manipulating video images.
import threading  # The library for managing threads.
from gesture_recognizer import recognize_gesture, detect_motion  # Features for gesture recognition and motion detection.

# The class for the music player.
class MusicPlayer:
    def __init__(self, master):
        self.master = master  # Reference to main window.
        self.master.title("Music Player")  # The title of the window.
        self.master.geometry("400x400")  # The size of the window.
        self.master.minsize(400, 400)  # Minimum window size.

        pygame.mixer.init()  # Initializes the mixer for playing sounds.

        # Player state variables.
        self.is_playing = False  # Indicates whether music is playing.
        self.is_repeat = False  # Indicates whether Repeat mode is active.
        self.current_time = 0  # The current time of the song.
        self.song_length = 0  # Total duration of the song.
        self.current_song_index = 0  # Current song index.
        self.songs = self.get_songs()  # Gets the playlist.
        self.last_repeat_time = 0  # The time of the last press of the Repeat button.
        self.repeat_cooldown = 2  # Two second cooldown for Repeat button.
        self.repeat_active_color = '#a0a0a0'  # The color of the activated Repeat button.
        self.repeat_inactive_color = '#e0e0e0'  # The color of the disabled Repeat button.

        self.create_widgets()  # Creates the interface elements.

        if self.songs:  # If there are songs, we load the first song.
            self.load_song()

        self.gesture_control_active = False  # Indicates whether gesture control is active.
        self.gesture_thread = None  # The gesture thread is initialized to None value.
        # Button to activate gesture control.
        self.gesture_control_button = tk.Button(self.master, text="Activare control gestual",
                                                command=self.toggle_gesture_control)
        self.gesture_control_button.pack(pady=10)  # Shows the button in the interface.

        # It updates the time and checks the end of the song periodically.
        self.master.after(100, self.update_time)
        self.master.after(500, self.check_end)

    # Function for creating GUI elements.
    def create_widgets(self):
        # The label that displays the song information.
        self.song_info_label = tk.Label(self.master, text="", font=("Arial", 12))
        self.song_info_label.pack(pady=5)  # Shows the label in the interface.

        # Frame for current time and total time.
        self.time_frame = tk.Frame(self.master)
        self.time_frame.pack(fill='x', padx=20)  # Shows the frame in the interface.

        # Tag for the current time of the song.
        self.current_time_label = tk.Label(self.time_frame, text="00:00")
        self.current_time_label.pack(side='left')  # Shows the label on the left.

        # Tag for the total time of the song.
        self.total_time_label = tk.Label(self.time_frame, text="00:00")
        self.total_time_label.pack(side='right')  # Shows the label on the right.

        # Progress bar for song playback.
        self.progress_canvas = tk.Canvas(self.master, height=10, bg="white")
        self.progress_canvas.pack(fill='x', padx=20)  # Shows progress bar.
        # Creates a blue progress bar.
        self.progress_bar = self.progress_canvas.create_rectangle(0, 0, 0, 10, fill="#1E90FF")

        # Frame for control buttons (Play, Next, Previous, etc.).
        self.control_frame = tk.Frame(self.master)
        self.control_frame.pack(pady=20)  # Shows the button frame.

        # Defines the buttons and their actions.
        button_data = [
            ("‚èÆ", self.previous, '#e0e0e0'),  # Previous button.
            ("‚ñ∂", self.play_pause, '#e0e0e0'),  # Play/Pause button.
            ("‚èπ", self.stop, '#e0e0e0'),  # Stop button.
            ("‚è≠", self.next, '#e0e0e0'),  # Next button.
            ("üîÅ", self.toggle_repeat, '#e0e0e0')  # Repeat button.
        ]

        self.buttons = {}  # Dictionary for storing buttons.
        for symbol, command, color in button_data:
            # Creates each button and add it to the interface.
            btn = tk.Button(self.control_frame, text=symbol, command=command,
                            font=("Arial", 16), width=3, bg=color)
            btn.pack(side='left', padx=10)  # Shows the button in the interface.
            # Adds hover effects to buttons.
            btn.bind("<Enter>", lambda e, b=btn: self.on_hover(b))
            btn.bind("<Leave>", lambda e, b=btn: self.on_leave(b))
            self.buttons[symbol] = btn  # Stores the button in the dictionary.

        # Slider for volume control.
        self.volume_var = tk.IntVar()  # Variable to store the volume value.
        self.volume_slider = ttk.Scale(self.master, from_=0, to=100, orient='horizontal',
                                       variable=self.volume_var, command=self.set_volume)
        self.volume_slider.set(50)  # Sets the initial volume to 50%.
        self.volume_slider.pack(fill='x', padx=20, pady=20)  # Shows the slider in the interface.

        # Binds various functions to keys (Play/Pause, Previous, Next, etc.).
        self.master.bind('<space>', lambda e: self.play_pause())  # Play/Pause button.
        self.master.bind('a', lambda e: self.previous())  # Previous button.
        self.master.bind('d', lambda e: self.next())  # Next button.
        self.master.bind('<Up>', lambda e: self.adjust_volume(5))  # Increases the sound volume.
        self.master.bind('<Down>', lambda e: self.adjust_volume(-5))  # Decreases the sound volume.
        self.master.bind('<Return>', lambda e: self.toggle_repeat())  # Enable/Disable Repeat option.
        self.master.bind('<Delete>', lambda e: self.stop())  # Stop playback.

    # Feature to enable/disable gesture control.
    def toggle_gesture_control(self):
        if self.gesture_control_active:  # If gesture control is active.
            self.gesture_control_active = False  # Disables gesture control.
            self.gesture_control_button.config(text="Activate gesture control")  # Changes the button text.
            if self.gesture_thread:  # If there is a thread for gestures.
                self.gesture_thread.join(timeout=1.0)  # Waits for the thread to end.
        else:  # If gesture control is disabled.
            self.gesture_control_active = True  # Activate gesture control.
            self.gesture_control_button.config(text="Disable gesture control")  # Changes the button text.
            self.gesture_thread = threading.Thread(target=self.process_gestures, daemon=True)  # Creates the thread for processing gestures.
            self.gesture_thread.start()  # Starts the execution thread.

    # The function that processes gestures using the video camera.
    def process_gestures(self):
        cap = cv2.VideoCapture(0)  # Turn on the video camera.
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)  # Sets the width of the video frame.
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)  # Sets the height of the video frame.

        last_gesture_time = time.time()  # The time of the last gesture processed.
        gesture_cooldown = 0.5  # 0.5 second cooldown between processing gestures.
        frame_interval = 0.1  # Interval between analyzed frames.
        prev_frame = None  # Previous framework for motion detection.

        while self.gesture_control_active:  # While gesture control is active.
            current_time = time.time()  # Current time.
            if current_time - last_gesture_time < frame_interval:  # Checks the interval between frames.
                time.sleep(0.01)  # Waits a little.
                continue  # Goes to the next frame.

            ret, frame = cap.read()  # Reads a frame from the video stream.
            if not ret:  # If it can't read the frame, it continues.
                continue

            frame = cv2.resize(frame, (160, 120))  # Resizes the video frame.

            if prev_frame is not None and not detect_motion(frame, prev_frame):  # Checks for motion between frames.
                prev_frame = frame  # Updates the previous frame.
                continue  # Goes to the next frame.

            gesture, confidence = recognize_gesture(frame)  # Recognizes the gesture in the frame.

            if gesture and confidence > 0.8 and (current_time - last_gesture_time) > gesture_cooldown:  # If the gesture is recognized with high confidence.
                last_gesture_time = current_time  # Updates the time of the last gesture.
                self.master.after(0, lambda g=gesture: self.execute_gesture_command(g))  # Executes the command associated with the gesture.

            prev_frame = frame  # Updates the previous frame.
            time.sleep(0.05)  # Waits before moving to the next frame.

        cap.release()  # Releases the video camera.

    # Function for executing the command associated with the recognized gesture.
    def execute_gesture_command(self, gesture):
        print(f"Executing gesture: {gesture}")  # Afi»ôƒÉm gestul recunoscut √Æn consolƒÉ.
        current_time = time.time()  # Timpul curent.
        if gesture == 'Play':  # DacƒÉ gestul este Play.
            if not self.is_playing:  # DacƒÉ muzica nu este redatƒÉ.
                self.simulate_button_press(self.buttons["‚ñ∂"])  # SimulƒÉm apƒÉsarea butonului Play.
                self.play_pause()  # Pornim redarea.
        elif gesture == 'Pause':  # DacƒÉ gestul este Pause.
            if self.is_playing:  # DacƒÉ muzica este redatƒÉ.
                self.simulate_button_press(self.buttons["‚ñ∂"])  # SimulƒÉm apƒÉsarea butonului Pause.
                self.play_pause()  # Punem pauzƒÉ.
        elif gesture == 'Next':  # DacƒÉ gestul este Next.
            self.simulate_button_press(self.buttons["‚è≠"])  # SimulƒÉm apƒÉsarea butonului Next.
            self.next()  # Trecem la melodia urmƒÉtoare.
        elif gesture == 'Previous':  # DacƒÉ gestul este Previous.
            self.simulate_button_press(self.buttons["‚èÆ"])  # SimulƒÉm apƒÉsarea butonului Previous.
            self.previous()  # Trecem la melodia precedentƒÉ.
        elif gesture == 'Volume Up':  # DacƒÉ gestul este pentru mƒÉrirea volumului.
            self.adjust_volume(5)  # MƒÉrim volumul cu 5 unitƒÉ»õi.
        elif gesture == 'Volume Down':  # DacƒÉ gestul este pentru mic»ôorarea volumului.
            self.adjust_volume(-5)  # Mic»ôorƒÉm volumul cu 5 unitƒÉ»õi.
        elif gesture == 'Thumb Up':  # DacƒÉ gestul este Thumb Up.
            if current_time - self.last_repeat_time > self.repeat_cooldown:  # VerificƒÉm dacƒÉ cooldown-ul pentru Repeat a expirat.
                self.simulate_button_press(self.buttons["üîÅ"])  # SimulƒÉm apƒÉsarea butonului Repeat.
                self.toggle_repeat()  # ActivƒÉm/DezactivƒÉm modul Repeat.
                self.last_repeat_time = current_time  # ActualizƒÉm timpul ultimei activƒÉri a Repeat.
        elif gesture == 'Victory':  # DacƒÉ gestul este Victory.
            self.simulate_button_press(self.buttons["‚èπ"])  # SimulƒÉm apƒÉsarea butonului Stop.
            self.stop()  # Oprim redarea muzicii.
        elif gesture == 'Rock and Roll':  # DacƒÉ gestul este Rock and Roll.
            print("Rock and Roll gesture detected. Closing application.")  # Afi»ôƒÉm mesajul »ôi √Ænchidem aplica»õia.
            self.master.after(0, self.master.quit)  # Ie»ôim din aplica»õie.

    # Func»õie pentru simularea apƒÉsƒÉrii unui buton din interfa»õƒÉ.
    def simulate_button_press(self, button):
        if button == self.buttons["üîÅ"]:  # Nu simulƒÉm apƒÉsarea pentru butonul Repeat, deoarece √Æ»ôi schimbƒÉ starea.
            return
        original_color = button.cget('bg')  # SalvƒÉm culoarea originalƒÉ a butonului.
        button.config(bg='#a0a0a0')  # SchimbƒÉm culoarea butonului pentru a simula apƒÉsarea.
        self.master.after(100, lambda: button.config(bg=original_color))  # Revenim la culoarea originalƒÉ dupƒÉ 100ms.

    # Func»õie pentru ob»õinerea listei de melodii din directorul Songs.
    def get_songs(self):
        songs_dir = os.path.join(os.path.dirname(__file__), 'Songs')  # Directorul √Æn care se aflƒÉ melodiile.
        if not os.path.exists(songs_dir):  # VerificƒÉm dacƒÉ directorul existƒÉ.
            print(f"Directory not found: {songs_dir}")  # Afi»ôƒÉm mesaj de eroare dacƒÉ directorul nu existƒÉ.
            return []  # ReturnƒÉm o listƒÉ goalƒÉ dacƒÉ directorul nu existƒÉ.
        songs = sorted([f for f in os.listdir(songs_dir) if f.endswith('.mp3')])  # FiltrƒÉm »ôi sortƒÉm fi»ôierele MP3.
        return songs  # ReturnƒÉm lista de melodii.

    # Func»õie pentru √ÆncƒÉrcarea unei melodii.
    def load_song(self):
        if not self.songs:  # VerificƒÉm dacƒÉ existƒÉ melodii √Æn listƒÉ.
            self.current_time_label.config(text="No songs")  # Afi»ôƒÉm mesajul dacƒÉ nu existƒÉ melodii.
            return

        song_path = os.path.join(os.path.dirname(__file__), 'Songs', self.songs[self.current_song_index])  # Calea cƒÉtre melodia curentƒÉ.
        pygame.mixer.music.load(song_path)  # √éncƒÉrcƒÉm melodia √Æn player.
        audio = MP3(song_path)  # Ob»õinem informa»õii despre melodia MP3 folosind mutagen.
        self.song_length = audio.info.length  # StocƒÉm durata totalƒÉ a melodiei.
        self.total_time_label.config(text=self.format_time(self.song_length))  # Afi»ôƒÉm durata totalƒÉ a melodiei.

        song_file = os.path.basename(song_path)  # Ob»õinem numele fi»ôierului melodiei.
        if '-' in song_file:  # DacƒÉ numele fi»ôierului con»õine caracterul '-'.
            artist, title = song_file.rsplit('-', 1)  # √émpƒÉr»õim numele fi»ôierului √Æn artist »ôi titlu.
            title = title.rsplit('.', 1)[0]  # EliminƒÉm extensia fi»ôierului.
            song_info = f"{artist.strip()} - {title.strip()}"  # FormatƒÉm informa»õiile despre artist »ôi titlu.
        else:
            artist = "Unknown"  # SetƒÉm artistul ca necunoscut dacƒÉ nu existƒÉ separatorul '-'.
            title = song_file.rsplit('.', 1)[0]  # Folosim numele fi»ôierului ca titlu.
            song_info = f"{artist.strip()} - {title.strip()}"  # FormatƒÉm informa»õiile.

        self.song_info_label.config(text=song_info)  # Afi»ôƒÉm informa»õiile despre melodia curentƒÉ.

    # Func»õie pentru a porni sau opri redarea muzicii.
    def play_pause(self):
        if not self.songs:  # DacƒÉ nu existƒÉ melodii, ie»ôim din func»õie.
            return
        if self.is_playing:  # DacƒÉ muzica este redatƒÉ, oprim redarea (pauzƒÉ).
            pygame.mixer.music.pause()  # Punem pauzƒÉ la melodia curentƒÉ.
            self.buttons["‚ñ∂"].config(text="‚ñ∂")  # SchimbƒÉm textul butonului la Play.
            self.is_playing = False  # SetƒÉm starea de redare pe False.
        else:  # DacƒÉ muzica nu este redatƒÉ.
            if pygame.mixer.music.get_pos() == -1:  # DacƒÉ melodia nu a √Ænceput niciodatƒÉ.
                pygame.mixer.music.play(start=self.current_time)  # RedƒÉm melodia de la timpul curent.
            else:
                pygame.mixer.music.unpause()  # ReluƒÉm redarea melodiei.
            self.buttons["‚ñ∂"].config(text="‚è∏")  # SchimbƒÉm textul butonului la Pause.
            self.is_playing = True  # SetƒÉm starea de redare pe True.

    # Func»õie pentru oprirea redƒÉrii muzicii.
    def stop(self):
        pygame.mixer.music.stop()  # Oprim redarea muzicii.
        self.is_playing = False  # SetƒÉm starea de redare pe False.
        self.current_time = 0  # ResetƒÉm timpul curent la 0.
        self.buttons["‚ñ∂"].config(text="‚ñ∂")  # SchimbƒÉm textul butonului la Play.
        self.current_time_label.config(text="00:00")  # ResetƒÉm eticheta timpului curent.
        self.update_progress_bar(0)  # ResetƒÉm bara de progres.

    # Func»õie pentru a trece la melodia precedentƒÉ.
    def previous(self):
        if not self.songs:  # DacƒÉ nu existƒÉ melodii, ie»ôim din func»õie.
            return
        self.current_song_index = (self.current_song_index - 1) % len(self.songs)  # Trecem la melodia precedentƒÉ √Æn listƒÉ.
        self.load_song()  # √éncƒÉrcƒÉm melodia.
        self.current_time = 0  # ResetƒÉm timpul curent la 0.
        if self.is_playing:  # DacƒÉ muzica este redatƒÉ.
            pygame.mixer.music.play()  # RedƒÉm melodia.

    # Func»õie pentru a trece la melodia urmƒÉtoare.
    def next(self):
        if not self.songs:  # DacƒÉ nu existƒÉ melodii, ie»ôim din func»õie.
            return
        self.current_song_index = (self.current_song_index + 1) % len(self.songs)  # Trecem la melodia urmƒÉtoare √Æn listƒÉ.
        self.load_song()  # √éncƒÉrcƒÉm melodia.
        self.current_time = 0  # ResetƒÉm timpul curent la 0.
        if self.is_playing:  # DacƒÉ muzica este redatƒÉ.
            pygame.mixer.music.play()  # RedƒÉm melodia.

    # Func»õie pentru activarea/dezactivarea modului Repeat.
    def toggle_repeat(self):
        self.is_repeat = not self.is_repeat  # ComutƒÉm starea Repeat (activat/dezactivat).
        if self.is_repeat:  # DacƒÉ Repeat este activat.
            self.buttons["üîÅ"].config(bg=self.repeat_active_color)  # SchimbƒÉm culoarea butonului Repeat la activat.
            self.buttons["üîÅ"].unbind("<Enter>")  # DezactivƒÉm efectul hover pentru butonul Repeat.
            self.buttons["üîÅ"].unbind("<Leave>")  # DezactivƒÉm efectul hover pentru butonul Repeat.
        else:  # DacƒÉ Repeat este dezactivat.
            self.buttons["üîÅ"].config(bg=self.repeat_inactive_color)  # SchimbƒÉm culoarea butonului Repeat la dezactivat.
            self.buttons["üîÅ"].bind("<Enter>", lambda e: self.on_hover(self.buttons["üîÅ"]))  # ReactivƒÉm efectul hover.
            self.buttons["üîÅ"].bind("<Leave>", lambda e: self.on_leave(self.buttons["üîÅ"]))  # ReactivƒÉm efectul hover.
        print(f"Repeat mode: {'On' if self.is_repeat else 'Off'}")  # Afi»ôƒÉm starea Repeat √Æn consolƒÉ.

    # Func»õie pentru verificarea sf√¢r»ôitului melodiei curente.
    def check_end(self):
        if self.is_playing:  # DacƒÉ muzica este redatƒÉ.
            if not pygame.mixer.music.get_busy():  # DacƒÉ melodia s-a terminat.
                if self.is_repeat:  # DacƒÉ modul Repeat este activat.
                    pygame.mixer.music.play()  # RedƒÉm melodia din nou.
                    self.current_time = 0  # ResetƒÉm timpul curent la 0.
                else:
                    self.next()  # Trecem la melodia urmƒÉtoare.
        self.master.after(500, self.check_end)  # VerificƒÉm din nou peste 500 ms.

    # Func»õie pentru actualizarea timpului curent »ôi a barei de progres.
    def update_time(self):
        if self.is_playing:  # DacƒÉ muzica este redatƒÉ.
            self.current_time = pygame.mixer.music.get_pos() / 1000  # Ob»õinem timpul curent al melodiei.
            if self.current_time >= 0:  # DacƒÉ timpul curent este valid.
                self.current_time_label.config(text=self.format_time(self.current_time))  # Afi»ôƒÉm timpul curent.
                self.update_progress_bar(self.current_time)  # ActualizƒÉm bara de progres.
        self.master.after(100, self.update_time)  # ActualizƒÉm din nou dupƒÉ 100 ms.

    # Func»õie pentru actualizarea barei de progres √Æn func»õie de timpul curent.
    def update_progress_bar(self, current_time):
        if self.song_length > 0:  # DacƒÉ durata melodiei este validƒÉ.
            progress_ratio = current_time / self.song_length  # CalculƒÉm procentajul de progres.
            progress_width = progress_ratio * self.progress_canvas.winfo_width()  # CalculƒÉm lƒÉ»õimea barei de progres.
            self.progress_canvas.coords(self.progress_bar, 0, 0, progress_width, 10)  # ActualizƒÉm bara de progres.

    # Func»õie pentru setarea volumului.
    def set_volume(self, value):
        volume = float(value) / 100  # Convertim valoarea volumului √Æntr-o propor»õie (√Æntre 0 »ôi 1).
        pygame.mixer.music.set_volume(volume)  # SetƒÉm volumul playerului.

    # Func»õie pentru ajustarea volumului cu o valoare datƒÉ.
    def adjust_volume(self, step):
        current_volume = self.volume_slider.get()  # Ob»õinem volumul curent.
        new_volume = max(0, min(100, current_volume + step))  # CalculƒÉm noul volum (√Æntre 0 »ôi 100).
        self.volume_slider.set(new_volume)  # SetƒÉm noul volum pe slider.
        self.set_volume(new_volume)  # SetƒÉm volumul playerului.

    # Func»õie pentru formatarea timpului √Æn minute »ôi secunde.
    def format_time(self, seconds):
        return time.strftime('%M:%S', time.gmtime(seconds))  # Convertim timpul √Æn format MM:SS.

    # Func»õie pentru efectul hover c√¢nd un buton este apƒÉsat.
    def on_hover(self, button):
        if button != self.buttons["üîÅ"] or not self.is_repeat:  # DacƒÉ butonul nu este Repeat sau Repeat este dezactivat.
            button.config(bg='#cccccc')  # SchimbƒÉm culoarea butonului la hover.

    # Func»õie pentru efectul de retragere a hover-ului c√¢nd butonul nu mai este apƒÉsat.
    def on_leave(self, button):
        if button != self.buttons["üîÅ"] or not self.is_repeat:  # DacƒÉ butonul nu este Repeat sau Repeat este dezactivat.
            button.config(bg=self.repeat_inactive_color)  # Revenim la culoarea inactivƒÉ.
        else:  # DacƒÉ Repeat este activat.
            button.config(bg=self.repeat_active_color)  # Men»õinem culoarea activƒÉ.

# Ini»õializƒÉm fereastra principalƒÉ »ôi playerul de muzicƒÉ.
if __name__ == "__main__":
    root = tk.Tk()  # CreƒÉm fereastra principalƒÉ.
    player = MusicPlayer(root)  # Ini»õializƒÉm playerul de muzicƒÉ.
    root.mainloop()  # Pornim bucla principalƒÉ a interfe»õei grafice.
